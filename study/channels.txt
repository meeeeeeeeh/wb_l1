Канал — это механизм связи, который, помимо прочего, позволяет горутинам обмениваться
 данными. Во-первых, каждый канал допускает обмен определенным типом данных, который 
 также называется типом элемента канала, а во-вторых, для правильной работы канала 
 вам понадобится кто-то, кто будет получать то, что отправляется по нему. 
 Новый канал можно объявить, используя make() и клю- чевое слово chan (make(chan int)),
а закрыть канал — с помощью функции close(). 
Вы можете объявить и размер канала, написав что-то вроде make(chan int, 1).


Конвейер — это виртуальный метод соединения горутин и каналов, так что выходные данные
одной горутины становятся входными данными другой, а для передачи ваших данных 
используются каналы. Одним из преимуществ использования конвейеров является то, 
то в вашей программе будет постоянный поток данных, так как ни одна горутина или 
канал не обязаны ждать завершения всего, чтобы начать выполнение. Кроме того, вы 
используете меньше перемен- ных и, следовательно, 
меньше места в памяти, так как нет необходимости со- хранять все в переменной. 

Записьзначение val в канал ch: ch <- val.
Прочитать значение из канала c можно, выполнив команду <-c. 
сохранить это значение в переменной, использовав aVar := <-c.


c := make(chan int, 1)
Этот канал имеет буфер с размером 1. 
Это означает, что, как только мы заполним буфер, мы сможем закрыть канал, 
а горутина продолжит свое выполнение и вернется. 

Канал, который не буферизован, ведет себя по-другому: когда вы отправляете значение в этот канал,
он блокируется до момента, пока кто-то получит это значение. 

Ключевое слово range работает с каналами! Однако цикл по range канала завершается только тогда, 
когда канал закрыт или использовано ключевое слово break. !!


Чтение из закрытого канала возвращает нулевое значение его типа данных. 
Но если вы попытаетесь выполнить запись в закрытый канал, ваша программа завершится ошибкой (panic). 


Состояние гонки данных — это ситуация, когда два или более запущенных элемента, 
таких как потоки и горутины, пытаются взять под контроль или изменить 
общий ресурс или общую переменную программы.
Гонка данных возникает, когда две или более команд обращаются к одному и тому же адресу памяти, 
куда по крайней мере одна из них выполняет опера- цию записи (изменения). 
Если все операции являются операциями чтения, то состояние гонки отсутствует.

Использование флага -race при запуске или сборке исходного кода Go запуска- ет Go-детектор гонки,
который заставляет компилятор создавать модифицированную версию типичного исполняемого файла.
- может записывать все обращения к общим переменным,
а также все происходящие события синхронизации, включая вызовы sync.Mutex и sync.WaitGroup


Go-детектор гонки. Вы можете запустить детектор гонки с помощью go run -race.
