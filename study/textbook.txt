Каналы соединяюn несколько горутин.
Горутины могут обрабатывать данные и выполнять команды, но не могут напрямую взаимодействовать друг с другом. 
В то же время каналы не могут обрабатывать данные или выполнять код, 
но могут отправлять данные в горутины, получать данные или иметь какое-то иное специальное на- значение.
Объединяя несколько каналов и горутин, вы получаете возможность создавать потоки данных, 
которые в терминологии Go также называются конвейерами.


Процесс — это представление операционной системой запущенной программы, в то время как программа представляет 
собой двоичный файл на диске, содержащий всю информацию, необходимую для создания процесса ОС.
Программа загружается в память, и инструкции выполняются, создавая запущенный процесс. Таким образом, 
процесс содержит дополнительные ресурсы, такие как память, описания открытых файлов и пользовательские данные

Поток — это объект меньшего размера и значимости. 
Процессы состоят из од- ного или нескольких потоков, у которых имеется свой поток команд управления и стек.

Горутина — это минимальная сущность в Go, которая может выполняться параллельно.
Горутины легче потоков, которые, в свою очередь, легче процессовю.


Планировщик ядра ОС отвечает за выполнение потоков программы. 
Аналогично среда выполнения Go имеет собственный планировщик, который отвечает за выполнение горутин.
При этом используется метод, известный как планирование m:n, 
где m горутин выполняется с помощью n потоков ОС с использованием мультиплексирования. 
Планировщик Go — это компонент, отвечающий за способ и порядок выполнения горутин Go-программы. 


Переменная среды GOMAXPROCS
func main() {
       fmt.Print("You are using ", runtime.Compiler, " ")     //You are using gc on a amd64 machine
       fmt.Println("on a", runtime.GOARCH, "machine")      //Using Go version go1.16.2
       fmt.Println("Using Go version", runtime.Version())    //GOMAXPROCS: 8
       fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
   }

runtime.Compiler содержит набор инструментов компилятора, ис- пользуемый для сборки запущенного двоичного файла
runtime.GOARCH содержит текущую архитектуру
runtime.Version() возвращает текущую версию компилятора Go.

Что происходит с вызовом runtime.GOMAXPROCS(0)? Функция runtime.GOMAXPROCS() всегда возвращает предыдущее значение 
максимального количества процессоров, которые могут выполняться одновременно. 
Когда параметр runtime.GOMAXPROCS() равен или больше 1, runtime.GOMAXPROCS() также изменяет текущую настройку. 
Поскольку мы используем 0, наш вызов не меняет текущую настройку.

Можно изменять значение GOMAXPROCS динамически:
$ export GOMAXPROCS=100; ->
GOMAXPROCS: 100


Параллелизм и распараллеливание:
Параллелизм — это одновременное выполнение нескольких объектов какого-либо вида, 
тогда как распараллеливание — это способ структурирования компонентов таким образом, 
чтобы они могли выполняться независимо, когда это возможно.



Горутины.
Вы можете определить, создать и выполнить новую горутину, 
используя ключевое слово go, за которым следует имя функции или анонимная функция.

Недостаточно создать несколько горутин‚ нужно еще дождаться их завершения до завершения функции main().
Процесс синхронизации начинается с определения переменной sync.WaitGroup 
и использования методов Add(), Done() и Wait()
WaitGroup — это не что иное, как структура с двумя полями:
   type WaitGroup struct {
       noCopy noCopy
       state1 [3]uint32
   }

Каждый вызов sync.Add() увеличивает счетчик в поле state1, которое представляет собой массив с
тремя элементами uint32. Важно вызвать sync.Add() перед операцией go, чтобы предотвратить какие-либо состояния гонки.
Когда горутина завершает свою работу, должна быть выполнена функция sync.Done(), уменьшающая тот же счетчик на единицу. 
«За кулисами» sync.Done() просто совершает вызов Add(-1).
Метод Wait() ожидает, пока этот счетчик не станет равным 0, после чего возвращается. 
Возврат Wait() внутри функции main() означает, что main() собирается вернуться и программа завершится.


Что делать, если количество вызовов Add() и Done() разное?
Когда количество вызовов sync.Add() и sync.Done() равно, в вашей программе все будет в порядке.
